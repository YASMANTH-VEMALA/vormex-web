{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///home/yasmanth/Pictures/vormex/vormex-web/src/lib/api/posts.ts"],"sourcesContent":["// Posts API - Complete API client for Posts & Feed endpoints\n\nimport apiClient from './client';\nimport type {\n  Post,\n  FeedResponse,\n  Comment,\n  CommentsResponse,\n  MentionUser,\n  MentionNotification,\n} from '@/types/post';\n\n// ============================================\n// Feed Endpoints\n// ============================================\n\n/**\n * Get home feed with cursor-based pagination\n * @param cursor - Optional cursor for pagination\n * @param limit - Number of posts per page (default: 20)\n */\nexport async function getFeed(cursor?: string, limit: number = 20): Promise<FeedResponse> {\n  const params: Record<string, any> = { limit };\n  if (cursor) params.cursor = cursor;\n  return apiClient.get('/posts/feed', { params });\n}\n\n/**\n * Get a single post by ID\n * @param postId - Post ID\n */\nexport async function getPost(postId: string): Promise<Post> {\n  return apiClient.get(`/posts/${postId}`);\n}\n\n// ============================================\n// Post CRUD Endpoints\n// ============================================\n\n/**\n * Create a new post (supports all post types)\n * Uses FormData for file uploads\n */\nexport async function createPost(formData: FormData): Promise<Post> {\n  // Content-Type is automatically handled by the request interceptor for FormData\n  return apiClient.post('/posts', formData);\n}\n\n/**\n * Delete a post\n * @param postId - Post ID to delete\n */\nexport async function deletePost(postId: string): Promise<{ success: boolean }> {\n  return apiClient.delete(`/posts/${postId}`);\n}\n\n/**\n * Update a post (content and visibility only)\n * @param postId - Post ID to update\n * @param data - Updated content and/or visibility\n */\nexport async function updatePost(\n  postId: string,\n  data: { content?: string; visibility?: string }\n): Promise<Post> {\n  return apiClient.put(`/posts/${postId}`, data);\n}\n\n// ============================================\n// Engagement Endpoints\n// ============================================\n\n/**\n * Toggle like on a post\n * @param postId - Post ID\n */\nexport async function toggleLike(postId: string): Promise<{ liked: boolean; likesCount: number }> {\n  return apiClient.post(`/posts/${postId}/like`);\n}\n\n/**\n * Vote on a poll\n * @param postId - Post ID\n * @param optionId - Poll option ID\n */\nexport async function votePoll(postId: string, optionId: string): Promise<{ success: boolean; pollOptions: any[] }> {\n  return apiClient.post(`/posts/${postId}/poll/vote`, { optionId });\n}\n\n/**\n * Share post to user(s)\n * @param postId - Post ID\n * @param userId - Target user ID to share with\n */\nexport async function sharePostToUser(postId: string, userId: string): Promise<{ message: string }> {\n  return apiClient.post(`/posts/${postId}/share`, { userId });\n}\n\n/**\n * Track post impression (view)\n * @param postId - Post ID\n * @param locationData - Optional location data\n */\nexport async function trackImpression(\n  postId: string,\n  locationData?: { lat: number; lng: number; city?: string; country?: string }\n): Promise<{ success: boolean }> {\n  return apiClient.post(`/posts/${postId}/impression`, locationData);\n}\n\n// ============================================\n// Comments Endpoints\n// ============================================\n\n/**\n * Get comments for a post\n * @param postId - Post ID\n * @param parentId - Optional parent comment ID for replies\n * @param page - Page number\n * @param limit - Comments per page\n */\nexport async function getComments(\n  postId: string,\n  parentId?: string,\n  page: number = 1,\n  limit: number = 20\n): Promise<CommentsResponse> {\n  const params: Record<string, any> = { page, limit };\n  if (parentId) params.parentId = parentId;\n  return apiClient.get(`/posts/${postId}/comments`, { params });\n}\n\n/**\n * Create a comment on a post\n * Note: This is handled via WebSocket for real-time updates\n * This is a fallback HTTP endpoint\n */\nexport async function createComment(\n  postId: string,\n  content: string,\n  parentId?: string,\n  mentions?: string[]\n): Promise<Comment> {\n  return apiClient.post(`/posts/${postId}/comments`, {\n    content,\n    parentId,\n    mentions,\n  });\n}\n\n/**\n * Toggle like on a comment\n * Note: This is handled via WebSocket for real-time updates\n */\nexport async function toggleCommentLike(\n  postId: string,\n  commentId: string\n): Promise<{ liked: boolean; likesCount: number }> {\n  return apiClient.post(`/posts/${postId}/comments/${commentId}/like`);\n}\n\n// ============================================\n// Mention Endpoints\n// ============================================\n\n/**\n * Search users for @mention autocomplete\n * @param query - Search query\n */\nexport async function searchUsersForMention(query: string): Promise<MentionUser[]> {\n  const res = await apiClient.get('/mentions/search', { params: { q: query } });\n  return (res as { users?: MentionUser[] }).users ?? [];\n}\n\n/**\n * Get unread mentions\n */\nexport async function getUnreadMentions(): Promise<MentionNotification[]> {\n  return apiClient.get('/mentions/unread');\n}\n\n/**\n * Get unread mention count\n */\nexport async function getUnreadMentionCount(): Promise<{ count: number }> {\n  return apiClient.get('/mentions/count');\n}\n\n/**\n * Mark mentions as read\n * @param mentionIds - Array of mention IDs to mark as read\n */\nexport async function markMentionsAsRead(mentionIds: string[]): Promise<{ success: boolean }> {\n  return apiClient.post('/mentions/read', { mentionIds });\n}\n\n// ============================================\n// Upload Endpoints\n// ============================================\n\n/**\n * Upload avatar image\n * @param file - Image file\n */\nexport async function uploadAvatar(file: File): Promise<{ avatarUrl: string }> {\n  const formData = new FormData();\n  formData.append('image', file);\n  return apiClient.post('/upload/avatar', formData, {\n    headers: { 'Content-Type': 'multipart/form-data' },\n  });\n}\n\n/**\n * Upload banner image\n * @param file - Image file\n */\nexport async function uploadBanner(file: File): Promise<{ bannerUrl: string }> {\n  const formData = new FormData();\n  formData.append('image', file);\n  return apiClient.post('/upload/banner', formData, {\n    headers: { 'Content-Type': 'multipart/form-data' },\n  });\n}\n\n/**\n * Upload certificate/document image\n * @param file - Image file\n */\nexport async function uploadCertificate(file: File): Promise<{ certificateUrl: string }> {\n  const formData = new FormData();\n  formData.append('image', file);\n  return apiClient.post('/upload/certificate', formData, {\n    headers: { 'Content-Type': 'multipart/form-data' },\n  });\n}\n\n/**\n * Upload project image\n * @param file - Image file\n */\nexport async function uploadProjectImage(file: File): Promise<{ imageUrl: string }> {\n  const formData = new FormData();\n  formData.append('image', file);\n  return apiClient.post('/upload/project', formData, {\n    headers: { 'Content-Type': 'multipart/form-data' },\n  });\n}\n\n/**\n * Delete an uploaded file\n * @param fileUrl - URL of file to delete\n * @param type - Type of file (avatar, banner, post)\n */\nexport async function deleteUpload(fileUrl: string, type: 'avatar' | 'banner' | 'post'): Promise<{ success: boolean }> {\n  return apiClient.delete('/upload', { data: { fileUrl, type } });\n}\n\n// ============================================\n// Location Endpoints\n// ============================================\n\n/**\n * Update user location\n */\nexport async function updateLocation(\n  lat: number,\n  lng: number,\n  accuracy?: number,\n  activity?: string\n): Promise<any> {\n  return apiClient.post('/location/update', { lat, lng, accuracy, activity });\n}\n\n/**\n * Get current user's location\n */\nexport async function getMyLocation(): Promise<any> {\n  return apiClient.get('/location/me');\n}\n\n/**\n * Get nearby users\n * @param radius - Search radius in km (default: 50)\n * @param limit - Max users to return (default: 20)\n */\nexport async function getNearbyUsers(radius?: number, limit?: number): Promise<any[]> {\n  const params: Record<string, any> = {};\n  if (radius) params.radius = radius;\n  if (limit) params.limit = limit;\n  return apiClient.get('/location/nearby', { params });\n}\n\n/**\n * Update location settings\n */\nexport async function updateLocationSettings(settings: {\n  locationPermission?: boolean;\n  shareLocationPublic?: boolean;\n}): Promise<{ message: string }> {\n  return apiClient.put('/location/settings', settings);\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 206, "column": 0}, "map": {"version":3,"sources":["file:///home/yasmanth/Pictures/vormex/vormex-web/src/lib/api/saved.ts"],"sourcesContent":["import apiClient from './client';\nimport type { Post } from '@/types/post';\n\nexport interface SavedPostsResponse {\n  posts: (Post & { savedAt?: string })[];\n  nextCursor: string | null;\n  hasMore: boolean;\n  pagination?: {\n    page: number;\n    limit: number;\n    totalCount: number;\n    totalPages: number;\n    hasMore: boolean;\n  };\n}\n\nexport interface ToggleSaveResponse {\n  message: string;\n  saved: boolean;\n  savesCount: number;\n}\n\n// Get all saved posts (cursor-based pagination)\nexport const getSavedPosts = async (\n  cursor?: string | null,\n  limit = 20\n): Promise<SavedPostsResponse> => {\n  const params: Record<string, string | number> = { limit };\n  if (cursor) params.cursor = cursor;\n  const res = (await apiClient.get('/saved', { params })) as unknown as SavedPostsResponse;\n  return {\n    posts: res.posts || [],\n    nextCursor: res.nextCursor ?? null,\n    hasMore: res.hasMore ?? false,\n    pagination: {\n      page: 1,\n      limit,\n      totalCount: res.posts?.length ?? 0,\n      totalPages: res.hasMore ? 2 : 1,\n      hasMore: res.hasMore ?? false,\n    },\n  };\n};\n\n// Toggle save status\nexport const toggleSavePost = async (postId: string): Promise<ToggleSaveResponse> => {\n  return apiClient.post(`/saved/${postId}/toggle`);\n};\n\n// Save a post\nexport const savePost = async (postId: string): Promise<{ message: string }> => {\n  return apiClient.post(`/saved/${postId}`);\n};\n\n// Unsave a post\nexport const unsavePost = async (postId: string): Promise<{ message: string }> => {\n  return apiClient.delete(`/saved/${postId}`);\n};\n\n// Check if post is saved\nexport const checkPostSaved = async (postId: string): Promise<{ saved: boolean }> => {\n  return apiClient.get(`/saved/${postId}/check`);\n};\n"],"names":[],"mappings":";;;;;;;;;;;;AAAA;;AAuBO,MAAM,gBAAgB,OAC3B,QACA,QAAQ,EAAE;IAEV,MAAM,SAA0C;QAAE;IAAM;IACxD,IAAI,QAAQ,OAAO,MAAM,GAAG;IAC5B,MAAM,MAAO,MAAM,sIAAS,CAAC,GAAG,CAAC,UAAU;QAAE;IAAO;IACpD,OAAO;QACL,OAAO,IAAI,KAAK,IAAI,EAAE;QACtB,YAAY,IAAI,UAAU,IAAI;QAC9B,SAAS,IAAI,OAAO,IAAI;QACxB,YAAY;YACV,MAAM;YACN;YACA,YAAY,IAAI,KAAK,EAAE,UAAU;YACjC,YAAY,IAAI,OAAO,GAAG,IAAI;YAC9B,SAAS,IAAI,OAAO,IAAI;QAC1B;IACF;AACF;AAGO,MAAM,iBAAiB,OAAO;IACnC,OAAO,sIAAS,CAAC,IAAI,CAAC,CAAC,OAAO,EAAE,OAAO,OAAO,CAAC;AACjD;AAGO,MAAM,WAAW,OAAO;IAC7B,OAAO,sIAAS,CAAC,IAAI,CAAC,CAAC,OAAO,EAAE,QAAQ;AAC1C;AAGO,MAAM,aAAa,OAAO;IAC/B,OAAO,sIAAS,CAAC,MAAM,CAAC,CAAC,OAAO,EAAE,QAAQ;AAC5C;AAGO,MAAM,iBAAiB,OAAO;IACnC,OAAO,sIAAS,CAAC,GAAG,CAAC,CAAC,OAAO,EAAE,OAAO,MAAM,CAAC;AAC/C"}},
    {"offset": {"line": 257, "column": 0}, "map": {"version":3,"sources":["file:///home/yasmanth/Pictures/vormex/vormex-web/src/lib/api/connections.ts"],"sourcesContent":["import apiClient from './client';\nimport type { PersonCard } from './people';\n\n// ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n// TYPES\n// ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\nexport type ConnectionStatus = 'none' | 'pending_sent' | 'pending_received' | 'connected' | 'blocked';\n\nexport interface Connection {\n  id: string;\n  status: 'PENDING' | 'ACCEPTED' | 'REJECTED' | 'BLOCKED';\n  message: string | null;\n  createdAt: string;\n  user: {\n    id: string;\n    username: string;\n    name: string;\n    profileImage: string | null;\n    headline: string | null;\n    college: string | null;\n  };\n}\n\nexport interface ConnectionsResponse {\n  connections: Connection[];\n  total: number;\n  page: number;\n  totalPages: number;\n  hasMore: boolean;\n}\n\nexport interface ConnectionStatusResponse {\n  status: ConnectionStatus;\n  connectionId?: string;\n  direction?: 'sent' | 'received';\n}\n\n// ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n// API FUNCTIONS\n// ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n/**\n * Send a connection request to another user\n */\nexport async function sendConnectionRequest(\n  receiverId: string,\n  message?: string\n): Promise<{ message: string; connection: Connection }> {\n  return apiClient.post('/connections/request', { receiverId, message });\n}\n\n/**\n * Accept a connection request\n */\nexport async function acceptConnectionRequest(\n  connectionId: string\n): Promise<{ message: string; connection: Connection }> {\n  return apiClient.post(`/connections/${connectionId}/accept`);\n}\n\n/**\n * Reject a connection request\n */\nexport async function rejectConnectionRequest(\n  connectionId: string\n): Promise<{ message: string }> {\n  return apiClient.post(`/connections/${connectionId}/reject`);\n}\n\n/**\n * Cancel a sent connection request\n */\nexport async function cancelConnectionRequest(\n  connectionId: string\n): Promise<{ message: string }> {\n  return apiClient.delete(`/connections/${connectionId}/cancel`);\n}\n\n/**\n * Remove an existing connection\n */\nexport async function removeConnection(\n  connectionId: string\n): Promise<{ message: string }> {\n  return apiClient.delete(`/connections/${connectionId}`);\n}\n\n/**\n * Get all connections for current user\n */\nexport async function getConnections(\n  page: number = 1,\n  limit: number = 20\n): Promise<ConnectionsResponse> {\n  return apiClient.get(`/connections?page=${page}&limit=${limit}`);\n}\n\n/**\n * Get all connections for a specific user\n */\nexport async function getUserConnections(\n  userId: string,\n  page: number = 1,\n  limit: number = 20\n): Promise<ConnectionsResponse> {\n  return apiClient.get(`/connections/user/${userId}?page=${page}&limit=${limit}`);\n}\n\n/**\n * Get pending connection requests (received)\n */\nexport async function getPendingRequests(\n  page: number = 1,\n  limit: number = 20\n): Promise<ConnectionsResponse> {\n  const response: any = await apiClient.get(`/connections/pending?page=${page}&limit=${limit}`);\n  // Backend returns 'requests', normalize to 'connections'\n  return {\n    connections: response.connections || response.requests || [],\n    total: response.total || 0,\n    page: response.page || page,\n    totalPages: response.totalPages || 1,\n    hasMore: response.hasMore || false,\n  };\n}\n\n/**\n * Get sent connection requests\n */\nexport async function getSentRequests(\n  page: number = 1,\n  limit: number = 20\n): Promise<ConnectionsResponse> {\n  const response: any = await apiClient.get(`/connections/sent?page=${page}&limit=${limit}`);\n  // Backend returns 'requests', normalize to 'connections'\n  return {\n    connections: response.connections || response.requests || [],\n    total: response.total || 0,\n    page: response.page || page,\n    totalPages: response.totalPages || 1,\n    hasMore: response.hasMore || false,\n  };\n}\n\n/**\n * Get connection status with a specific user\n */\nexport async function getConnectionStatus(\n  userId: string\n): Promise<ConnectionStatusResponse> {\n  return apiClient.get(`/connections/status/${userId}`);\n}\n\n/**\n * Block a user\n */\nexport async function blockUser(\n  userId: string\n): Promise<{ message: string }> {\n  return apiClient.post(`/users/${userId}/block`);\n}\n\n/**\n * Unblock a user\n */\nexport async function unblockUser(\n  userId: string\n): Promise<{ message: string }> {\n  return apiClient.delete(`/users/${userId}/block`);\n}\n\n/**\n * Get blocked users\n */\nexport async function getBlockedUsers(\n  page: number = 1,\n  limit: number = 20\n): Promise<{ users: Array<{ id: string; username: string; name: string; profileImage: string | null }>; total: number; hasMore: boolean }> {\n  return apiClient.get(`/users/blocked?page=${page}&limit=${limit}`);\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;;AA6CO,eAAe,sBACpB,UAAkB,EAClB,OAAgB;IAEhB,OAAO,sIAAS,CAAC,IAAI,CAAC,wBAAwB;QAAE;QAAY;IAAQ;AACtE;AAKO,eAAe,wBACpB,YAAoB;IAEpB,OAAO,sIAAS,CAAC,IAAI,CAAC,CAAC,aAAa,EAAE,aAAa,OAAO,CAAC;AAC7D;AAKO,eAAe,wBACpB,YAAoB;IAEpB,OAAO,sIAAS,CAAC,IAAI,CAAC,CAAC,aAAa,EAAE,aAAa,OAAO,CAAC;AAC7D;AAKO,eAAe,wBACpB,YAAoB;IAEpB,OAAO,sIAAS,CAAC,MAAM,CAAC,CAAC,aAAa,EAAE,aAAa,OAAO,CAAC;AAC/D;AAKO,eAAe,iBACpB,YAAoB;IAEpB,OAAO,sIAAS,CAAC,MAAM,CAAC,CAAC,aAAa,EAAE,cAAc;AACxD;AAKO,eAAe,eACpB,OAAe,CAAC,EAChB,QAAgB,EAAE;IAElB,OAAO,sIAAS,CAAC,GAAG,CAAC,CAAC,kBAAkB,EAAE,KAAK,OAAO,EAAE,OAAO;AACjE;AAKO,eAAe,mBACpB,MAAc,EACd,OAAe,CAAC,EAChB,QAAgB,EAAE;IAElB,OAAO,sIAAS,CAAC,GAAG,CAAC,CAAC,kBAAkB,EAAE,OAAO,MAAM,EAAE,KAAK,OAAO,EAAE,OAAO;AAChF;AAKO,eAAe,mBACpB,OAAe,CAAC,EAChB,QAAgB,EAAE;IAElB,MAAM,WAAgB,MAAM,sIAAS,CAAC,GAAG,CAAC,CAAC,0BAA0B,EAAE,KAAK,OAAO,EAAE,OAAO;IAC5F,yDAAyD;IACzD,OAAO;QACL,aAAa,SAAS,WAAW,IAAI,SAAS,QAAQ,IAAI,EAAE;QAC5D,OAAO,SAAS,KAAK,IAAI;QACzB,MAAM,SAAS,IAAI,IAAI;QACvB,YAAY,SAAS,UAAU,IAAI;QACnC,SAAS,SAAS,OAAO,IAAI;IAC/B;AACF;AAKO,eAAe,gBACpB,OAAe,CAAC,EAChB,QAAgB,EAAE;IAElB,MAAM,WAAgB,MAAM,sIAAS,CAAC,GAAG,CAAC,CAAC,uBAAuB,EAAE,KAAK,OAAO,EAAE,OAAO;IACzF,yDAAyD;IACzD,OAAO;QACL,aAAa,SAAS,WAAW,IAAI,SAAS,QAAQ,IAAI,EAAE;QAC5D,OAAO,SAAS,KAAK,IAAI;QACzB,MAAM,SAAS,IAAI,IAAI;QACvB,YAAY,SAAS,UAAU,IAAI;QACnC,SAAS,SAAS,OAAO,IAAI;IAC/B;AACF;AAKO,eAAe,oBACpB,MAAc;IAEd,OAAO,sIAAS,CAAC,GAAG,CAAC,CAAC,oBAAoB,EAAE,QAAQ;AACtD;AAKO,eAAe,UACpB,MAAc;IAEd,OAAO,sIAAS,CAAC,IAAI,CAAC,CAAC,OAAO,EAAE,OAAO,MAAM,CAAC;AAChD;AAKO,eAAe,YACpB,MAAc;IAEd,OAAO,sIAAS,CAAC,MAAM,CAAC,CAAC,OAAO,EAAE,OAAO,MAAM,CAAC;AAClD;AAKO,eAAe,gBACpB,OAAe,CAAC,EAChB,QAAgB,EAAE;IAElB,OAAO,sIAAS,CAAC,GAAG,CAAC,CAAC,oBAAoB,EAAE,KAAK,OAAO,EAAE,OAAO;AACnE"}},
    {"offset": {"line": 349, "column": 0}, "map": {"version":3,"sources":["file:///home/yasmanth/Pictures/vormex/vormex-web/src/lib/api/chat.ts"],"sourcesContent":["import apiClient from './client';\n\n// ============================================\n// Types\n// ============================================\n\nexport interface ChatUser {\n  id: string;\n  username: string;\n  name: string;\n  profileImage: string | null;\n  isOnline: boolean;\n  lastActiveAt: string | null;\n}\n\nexport interface Message {\n  id: string;\n  conversationId: string;\n  senderId: string;\n  receiverId: string;\n  content: string;\n  contentType: string;\n  mediaUrl?: string;\n  mediaType?: string;\n  fileName?: string;\n  fileSize?: number;\n  status: 'SENT' | 'DELIVERED' | 'READ';\n  deliveredAt?: string;\n  readAt?: string;\n  isDeleted: boolean;\n  isEdited?: boolean; // Client-side flag to track if message was edited\n  replyToId?: string;\n  replyTo?: {\n    id: string;\n    content: string;\n    contentType: string;\n    senderId: string;\n  };\n  sender: ChatUser;\n  reactions: MessageReaction[];\n  createdAt: string;\n  updatedAt: string;\n}\n\nexport interface MessageReaction {\n  id: string;\n  userId: string;\n  emoji: string;\n  user: {\n    id: string;\n    username: string;\n    name: string;\n  };\n}\n\nexport interface Conversation {\n  id: string;\n  participant1Id: string;\n  participant2Id: string;\n  participant1: ChatUser;\n  participant2: ChatUser;\n  otherParticipant: ChatUser;\n  lastMessage?: {\n    id: string;\n    content: string;\n    contentType: string;\n    senderId: string;\n    status: 'SENT' | 'DELIVERED' | 'READ';\n    createdAt: string;\n  };\n  lastMessageAt?: string;\n  unreadCount: number;\n  createdAt: string;\n  updatedAt: string;\n}\n\nexport interface ConversationsResponse {\n  conversations: Conversation[];\n  hasMore: boolean;\n  nextCursor?: string;\n}\n\nexport interface MessagesResponse {\n  messages: Message[];\n  hasMore: boolean;\n  nextCursor?: string;\n}\n\n// ============================================\n// Chat API Functions\n// ============================================\n\n/**\n * Get all conversations for the current user\n */\nexport async function getConversations(\n  limit?: number,\n  cursor?: string\n): Promise<ConversationsResponse> {\n  const params = new URLSearchParams();\n  if (limit) params.append('limit', String(limit));\n  if (cursor) params.append('cursor', cursor);\n  \n  return apiClient.get(`/chat/conversations?${params.toString()}`);\n}\n\n/**\n * Get or create a conversation with another user\n */\nexport async function getOrCreateConversation(participantId: string): Promise<Conversation> {\n  return apiClient.post('/chat/conversations', { participantId });\n}\n\n/**\n * Get a specific conversation\n */\nexport async function getConversation(conversationId: string): Promise<Conversation> {\n  return apiClient.get(`/chat/conversations/${conversationId}`);\n}\n\n/**\n * Get messages for a conversation\n */\nexport async function getMessages(\n  conversationId: string,\n  limit?: number,\n  cursor?: string\n): Promise<MessagesResponse> {\n  const params = new URLSearchParams();\n  if (limit) params.append('limit', String(limit));\n  if (cursor) params.append('cursor', cursor);\n  \n  return apiClient.get(`/chat/conversations/${conversationId}/messages?${params.toString()}`);\n}\n\n/**\n * Send a message (REST fallback - prefer WebSocket)\n */\nexport async function sendMessage(\n  conversationId: string,\n  data: {\n    content: string;\n    contentType?: string;\n    mediaUrl?: string;\n    mediaType?: string;\n    fileName?: string;\n    fileSize?: number;\n    replyToId?: string;\n  }\n): Promise<Message> {\n  return apiClient.post(`/chat/conversations/${conversationId}/messages`, data);\n}\n\n/**\n * Mark messages as read\n */\nexport async function markAsRead(conversationId: string): Promise<{ updatedCount: number; readAt: string }> {\n  return apiClient.post(`/chat/conversations/${conversationId}/read`);\n}\n\n/**\n * Delete a message\n */\nexport async function deleteMessage(\n  messageId: string,\n  forEveryone?: boolean\n): Promise<{ success: boolean }> {\n  return apiClient.delete(`/chat/messages/${messageId}`, { \n    data: { forEveryone } \n  });\n}\n\n/**\n * Edit a message\n */\nexport async function editMessage(messageId: string, content: string): Promise<Message> {\n  return apiClient.patch(`/chat/messages/${messageId}`, { content });\n}\n\n/**\n * Add reaction to a message\n */\nexport async function addReaction(\n  messageId: string,\n  emoji: string\n): Promise<{ action: 'added' | 'removed' | 'updated'; emoji: string }> {\n  return apiClient.post(`/chat/messages/${messageId}/reactions`, { emoji });\n}\n\n/**\n * Get unread message count\n */\nexport async function getUnreadCount(): Promise<{ unreadCount: number }> {\n  return apiClient.get('/chat/unread-count');\n}\n\n/**\n * Search messages\n */\nexport async function searchMessages(\n  query: string,\n  limit?: number\n): Promise<{ messages: Message[] }> {\n  const params = new URLSearchParams();\n  params.append('q', query);\n  if (limit) params.append('limit', String(limit));\n  \n  return apiClient.get(`/chat/search?${params.toString()}`);\n}\n\n/**\n * Upload chat media (image, video, document, audio)\n */\nexport async function uploadChatMedia(\n  file: File,\n  mediaType: 'image' | 'video' | 'document' | 'audio',\n  onProgress?: (progress: number) => void\n): Promise<{\n  mediaUrl: string;\n  fileName: string;\n  fileSize: number;\n  mediaType: string;\n}> {\n  const formData = new FormData();\n  formData.append('file', file);\n  formData.append('mediaType', mediaType);\n  \n  // Use axios with proper config for file uploads\n  return apiClient.post('/chat/upload', formData, {\n    timeout: 120000, // 2 minutes timeout for large files\n    maxContentLength: Infinity,\n    maxBodyLength: Infinity,\n    onUploadProgress: (progressEvent) => {\n      if (onProgress && progressEvent.total) {\n        const progress = Math.round((progressEvent.loaded / progressEvent.total) * 100);\n        onProgress(progress);\n      }\n    },\n  });\n}\n\n// ============================================\n// Message Limit (Connection-based)\n// ============================================\n\nexport interface MessageLimitStatus {\n  canSend: boolean;\n  isConnected: boolean;\n  messagesSent: number;\n  messagesRemaining: number;\n  limit: number;\n}\n\n/**\n * Get message limit status for a user\n * Non-connected users can only send 2 messages\n * Connected users have unlimited messaging\n */\nexport async function getMessageLimitStatus(userId: string): Promise<MessageLimitStatus> {\n  return apiClient.get(`/chat/message-limit/${userId}`);\n}\n\n// ============================================\n// Message Requests (from non-connected users)\n// ============================================\n\nexport interface MessageRequest extends Conversation {\n  isMessageRequest: boolean;\n  messageRequestAcceptedAt: string | null;\n}\n\nexport interface MessageRequestsResponse {\n  messageRequests: MessageRequest[];\n  hasMore: boolean;\n  nextCursor?: string;\n}\n\n/**\n * Get message requests (conversations from non-connected users)\n */\nexport async function getMessageRequests(\n  limit?: number,\n  cursor?: string\n): Promise<MessageRequestsResponse> {\n  const params = new URLSearchParams();\n  if (limit) params.append('limit', String(limit));\n  if (cursor) params.append('cursor', cursor);\n  \n  return apiClient.get(`/chat/requests?${params.toString()}`);\n}\n\n/**\n * Get message requests count\n */\nexport async function getMessageRequestsCount(): Promise<{ count: number }> {\n  return apiClient.get('/chat/requests/count');\n}\n\n/**\n * Accept a message request\n */\nexport async function acceptMessageRequest(\n  conversationId: string\n): Promise<{ message: string; conversation: Conversation }> {\n  return apiClient.post(`/chat/requests/${conversationId}/accept`);\n}\n\n/**\n * Decline a message request\n */\nexport async function declineMessageRequest(\n  conversationId: string\n): Promise<{ message: string }> {\n  return apiClient.delete(`/chat/requests/${conversationId}`);\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 478, "column": 0}, "map": {"version":3,"sources":["file:///home/yasmanth/Pictures/vormex/vormex-web/src/lib/api/reports.ts"],"sourcesContent":["import apiClient from './client';\n\nexport interface ReportReason {\n  value: string;\n  label: string;\n  description: string;\n}\n\nexport interface ReportResponse {\n  message: string;\n  reportId: string;\n}\n\nexport interface MyReport {\n  id: string;\n  reportType: 'POST' | 'CHAT' | 'USER' | 'COMMENT' | 'GROUP';\n  reason: string;\n  description: string | null;\n  status: 'PENDING' | 'UNDER_REVIEW' | 'RESOLVED' | 'DISMISSED';\n  actionTaken: string;\n  createdAt: string;\n  reviewedAt: string | null;\n  post: {\n    id: string;\n    content: string;\n    type: string;\n  } | null;\n  reportedUser: {\n    id: string;\n    name: string;\n    username: string;\n    profileImage: string | null;\n  } | null;\n}\n\nexport interface ReportRequest {\n  reason: string;\n  description?: string;\n}\n\nexport interface ChatReportRequest extends ReportRequest {\n  reportedUserId: string;\n}\n\nexport const reportAPI = {\n  // Get available report reasons\n  getReasons: async (): Promise<{ reasons: ReportReason[] }> => {\n    return apiClient.get('/reports/reasons');\n  },\n\n  // Report a post\n  reportPost: async (postId: string, data: ReportRequest): Promise<ReportResponse> => {\n    return apiClient.post(`/reports/post/${postId}`, data);\n  },\n\n  // Report a comment\n  reportComment: async (commentId: string, data: ReportRequest): Promise<ReportResponse> => {\n    return apiClient.post(`/reports/comment/${commentId}`, data);\n  },\n\n  // Report a user in chat\n  reportChatUser: async (conversationId: string, data: ChatReportRequest): Promise<ReportResponse> => {\n    return apiClient.post(`/reports/chat/${conversationId}`, data);\n  },\n\n  // Report a user profile\n  reportUser: async (userId: string, data: ReportRequest): Promise<ReportResponse> => {\n    return apiClient.post(`/reports/user/${userId}`, data);\n  },\n\n  // Report a group\n  reportGroup: async (groupId: string, data: ReportRequest): Promise<ReportResponse> => {\n    return apiClient.post(`/reports/group/${groupId}`, data);\n  },\n\n  // Get user's own reports\n  getMyReports: async (page = 1, limit = 10): Promise<{\n    reports: MyReport[];\n    pagination: {\n      page: number;\n      limit: number;\n      total: number;\n      totalPages: number;\n    };\n  }> => {\n    return apiClient.get(`/reports/my-reports?page=${page}&limit=${limit}`);\n  },\n};\n"],"names":[],"mappings":";;;;AAAA;;AA4CO,MAAM,YAAY;IACvB,+BAA+B;IAC/B,YAAY;QACV,OAAO,sIAAS,CAAC,GAAG,CAAC;IACvB;IAEA,gBAAgB;IAChB,YAAY,OAAO,QAAgB;QACjC,OAAO,sIAAS,CAAC,IAAI,CAAC,CAAC,cAAc,EAAE,QAAQ,EAAE;IACnD;IAEA,mBAAmB;IACnB,eAAe,OAAO,WAAmB;QACvC,OAAO,sIAAS,CAAC,IAAI,CAAC,CAAC,iBAAiB,EAAE,WAAW,EAAE;IACzD;IAEA,wBAAwB;IACxB,gBAAgB,OAAO,gBAAwB;QAC7C,OAAO,sIAAS,CAAC,IAAI,CAAC,CAAC,cAAc,EAAE,gBAAgB,EAAE;IAC3D;IAEA,wBAAwB;IACxB,YAAY,OAAO,QAAgB;QACjC,OAAO,sIAAS,CAAC,IAAI,CAAC,CAAC,cAAc,EAAE,QAAQ,EAAE;IACnD;IAEA,iBAAiB;IACjB,aAAa,OAAO,SAAiB;QACnC,OAAO,sIAAS,CAAC,IAAI,CAAC,CAAC,eAAe,EAAE,SAAS,EAAE;IACrD;IAEA,yBAAyB;IACzB,cAAc,OAAO,OAAO,CAAC,EAAE,QAAQ,EAAE;QASvC,OAAO,sIAAS,CAAC,GAAG,CAAC,CAAC,yBAAyB,EAAE,KAAK,OAAO,EAAE,OAAO;IACxE;AACF"}},
    {"offset": {"line": 518, "column": 0}, "map": {"version":3,"sources":["file:///home/yasmanth/Pictures/vormex/vormex-web/src/lib/api/stories.ts"],"sourcesContent":["import apiClient from './client';\n\n// ============================================\n// Types\n// ============================================\n\nexport type StoryMediaType = 'IMAGE' | 'VIDEO' | 'TEXT';\nexport type StoryCategory = 'GENERAL' | 'DAY_AT_WORK' | 'LEARNING' | 'ACHIEVEMENT' | 'PROJECT' | 'EVENT' | 'BEHIND_SCENES' | 'TIPS' | 'QNA';\nexport type StoryVisibility = 'PUBLIC' | 'CONNECTIONS' | 'CLOSE_FRIENDS';\n\nexport interface StoryAuthor {\n  id: string;\n  name: string;\n  username: string;\n  profileImage: string | null;\n  headline?: string | null;\n  isVerified?: boolean;\n}\n\nexport interface Story {\n  id: string;\n  mediaUrl: string;\n  mediaType: StoryMediaType;\n  thumbnailUrl?: string | null;\n  duration: number;\n  category: StoryCategory;\n  backgroundColor?: string | null;\n  textContent?: string | null;\n  textPosition?: { x: number; y: number } | null;\n  textStyle?: { fontSize?: number; fontWeight?: string; color?: string } | null;\n  stickers?: any[] | null;\n  filters?: string | null;\n  musicUrl?: string | null;\n  musicTitle?: string | null;\n  musicArtist?: string | null;\n  linkUrl?: string | null;\n  linkTitle?: string | null;\n  visibility: StoryVisibility;\n  viewsCount: number;\n  reactionsCount: number;\n  repliesCount?: number;\n  isViewed: boolean;\n  userReaction?: string | null;\n  isOwn?: boolean;\n  expiresAt: string;\n  createdAt: string;\n}\n\nexport interface StoryGroup {\n  user: StoryAuthor;\n  stories: Story[];\n  hasUnviewed: boolean;\n  lastStoryAt: string;\n  isOwnStory: boolean;\n}\n\nexport interface StoryHighlight {\n  id: string;\n  title: string;\n  coverImage: string | null;\n  emoji?: string | null;\n  storiesCount: number;\n  isPublic: boolean;\n  createdAt: string;\n}\n\nexport interface StoryViewer {\n  id: string;\n  user: StoryAuthor;\n  viewedAt: string;\n  duration?: number | null;\n}\n\nexport interface StoryReply {\n  id: string;\n  content: string;\n  mediaUrl?: string | null;\n  author: StoryAuthor;\n  createdAt: string;\n}\n\n// ============================================\n// Story CRUD\n// ============================================\n\nexport interface CreateStoryInput {\n  mediaUrl?: string;\n  mediaType?: StoryMediaType;\n  thumbnailUrl?: string;\n  duration?: number;\n  category?: StoryCategory;\n  backgroundColor?: string;\n  textContent?: string;\n  textPosition?: { x: number; y: number };\n  textStyle?: { fontSize?: number; fontWeight?: string; color?: string };\n  stickers?: any[];\n  filters?: string;\n  musicUrl?: string;\n  musicTitle?: string;\n  musicArtist?: string;\n  linkUrl?: string;\n  linkTitle?: string;\n  visibility?: StoryVisibility;\n  mentions?: string[];\n}\n\nexport const createStory = async (data: CreateStoryInput): Promise<{ message: string; story: Story }> => {\n  // apiClient interceptor already returns response.data\n  return apiClient.post('/stories', data);\n};\n\n// Create story with file upload\nexport const createStoryWithMedia = async (formData: FormData): Promise<{ message: string; story: Story }> => {\n  // apiClient interceptor already returns response.data\n  return apiClient.post('/stories', formData, {\n    headers: {\n      'Content-Type': 'multipart/form-data',\n    },\n  });\n};\n\nexport const getStoriesFeed = async (): Promise<{ storyGroups: StoryGroup[] }> => {\n  try {\n    // apiClient interceptor already returns response.data, so this IS the data\n    const response = await apiClient.get('/stories/feed');\n    const data = response.data || response;\n    console.log('üìñ Stories API raw response:', data);\n    \n    // Ensure we always return the expected structure\n    if (data && Array.isArray(data.storyGroups)) {\n      return { storyGroups: data.storyGroups };\n    }\n    \n    // If response is already an array, wrap it\n    if (Array.isArray(data)) {\n      return { storyGroups: data };\n    }\n    \n    // Default empty array\n    return { storyGroups: [] };\n  } catch (error) {\n    console.error('üìñ Stories API error:', error);\n    throw error;\n  }\n};\n\nexport const getStory = async (storyId: string): Promise<{ story: Story & { isOwn: boolean } }> => {\n  return apiClient.get(`/stories/${storyId}`);\n};\n\nexport const getMyStories = async (includeExpired = false): Promise<{ stories: Story[] }> => {\n  return apiClient.get('/stories/me', {\n    params: { includeExpired },\n  });\n};\n\nexport const deleteStory = async (storyId: string): Promise<{ message: string }> => {\n  return apiClient.delete(`/stories/${storyId}`);\n};\n\nexport const getUserStories = async (userId: string): Promise<{\n  hasStories: boolean;\n  user?: StoryAuthor;\n  hasUnviewed?: boolean;\n  stories?: Story[];\n}> => {\n  return apiClient.get(`/stories/user/${userId}`);\n};\n\n// ============================================\n// Story Viewing\n// ============================================\n\nexport const viewStory = async (storyId: string, duration?: number): Promise<{ message: string; viewsCount: number }> => {\n  return apiClient.post(`/stories/${storyId}/view`, { duration });\n};\n\nexport const getStoryViewers = async (\n  storyId: string,\n  cursor?: string,\n  limit = 20\n): Promise<{\n  viewers: StoryViewer[];\n  nextCursor: string | null;\n  hasMore: boolean;\n}> => {\n  return apiClient.get(`/stories/${storyId}/viewers`, {\n    params: { cursor, limit },\n  });\n};\n\n// ============================================\n// Story Reactions\n// ============================================\n\nexport const reactToStory = async (\n  storyId: string,\n  reactionType: string\n): Promise<{ message: string; reactionType: string; reactionsCount: number }> => {\n  return apiClient.post(`/stories/${storyId}/react`, { reactionType });\n};\n\nexport const removeReaction = async (storyId: string): Promise<{ message: string; reactionsCount: number }> => {\n  return apiClient.delete(`/stories/${storyId}/react`);\n};\n\n// ============================================\n// Story Replies\n// ============================================\n\nexport const replyToStory = async (\n  storyId: string,\n  content: string,\n  mediaUrl?: string\n): Promise<{ message: string; reply: StoryReply }> => {\n  return apiClient.post(`/stories/${storyId}/reply`, { content, mediaUrl });\n};\n\nexport const getStoryReplies = async (storyId: string): Promise<{ replies: StoryReply[] }> => {\n  return apiClient.get(`/stories/${storyId}/replies`);\n};\n\n// ============================================\n// Highlights\n// ============================================\n\nexport interface CreateHighlightInput {\n  title: string;\n  coverImage?: string;\n  emoji?: string;\n  storyIds?: string[];\n}\n\nexport const createHighlight = async (data: CreateHighlightInput): Promise<{ message: string; highlight: StoryHighlight }> => {\n  return apiClient.post('/stories/highlights', data);\n};\n\nexport const getUserHighlights = async (userId: string): Promise<{ highlights: StoryHighlight[] }> => {\n  return apiClient.get(`/stories/highlights/user/${userId}`);\n};\n\nexport const getHighlightStories = async (highlightId: string): Promise<{\n  highlight: StoryHighlight & { user: StoryAuthor; stories: Story[] };\n}> => {\n  return apiClient.get(`/stories/highlights/${highlightId}`);\n};\n\nexport const updateHighlight = async (\n  highlightId: string,\n  data: Partial<CreateHighlightInput>\n): Promise<{ message: string; highlight: StoryHighlight }> => {\n  return apiClient.patch(`/stories/highlights/${highlightId}`, data);\n};\n\nexport const deleteHighlight = async (highlightId: string): Promise<{ message: string }> => {\n  return apiClient.delete(`/stories/highlights/${highlightId}`);\n};\n\nexport const addStoryToHighlight = async (highlightId: string, storyId: string): Promise<{ message: string }> => {\n  return apiClient.post(`/stories/highlights/${highlightId}/stories/${storyId}`);\n};\n\nexport const removeStoryFromHighlight = async (highlightId: string, storyId: string): Promise<{ message: string }> => {\n  return apiClient.delete(`/stories/highlights/${highlightId}/stories/${storyId}`);\n};\n\n// ============================================\n// Archive\n// ============================================\n\nexport const archiveStory = async (storyId: string): Promise<{ message: string }> => {\n  return apiClient.post(`/stories/${storyId}/archive`);\n};\n\nexport const getArchivedStories = async (): Promise<{ stories: Story[] }> => {\n  return apiClient.get('/stories/archive');\n};\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 682, "column": 0}, "map": {"version":3,"sources":["file:///home/yasmanth/Pictures/vormex/vormex-web/src/lib/api/variable-rewards.ts"],"sourcesContent":["import apiClient from './client';\n\n// ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n// VARIABLE REWARDS TYPES\n// ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\nexport type RewardCardType =\n  | 'MATCH_BURST'\n  | 'TRENDING'\n  | 'HIDDEN_GEM'\n  | 'MILESTONE'\n  | 'OPPORTUNITY'\n  | 'SOCIAL_PROOF'\n  | 'SURPRISE_BOOST'\n  | 'CONNECTION_UPDATE';\n\nexport interface MatchUser {\n  id: string;\n  name: string;\n  username: string;\n  profileImage: string | null;\n  college: string | null;\n  branch: string | null;\n  headline: string | null;\n  interests: string[];\n}\n\nexport interface TrendingData {\n  hasSpike: boolean;\n  recentViews: number;\n  previousViews: number;\n  increasePercent: number;\n}\n\nexport interface MilestoneData {\n  id: string;\n  type: string;\n  value: number;\n  title: string;\n  description: string;\n  icon: string;\n  unlockedAt: string;\n}\n\nexport interface OpportunityData {\n  id: string;\n  title: string;\n  type: string;\n  company: string;\n  location: string;\n  createdAt: string;\n}\n\nexport interface ViewerData {\n  id: string;\n  viewId: string;\n  name: string;\n  username: string;\n  profileImage: string | null;\n  college: string | null;\n  viewedAt: string;\n}\n\nexport interface SurpriseBoostData {\n  eligible: boolean;\n  activeDays: number;\n  xpAmount: number;\n  reason: string;\n}\n\nexport interface ConnectionUpdateData {\n  hasUpdates: boolean;\n  recentAccepts: Array<{\n    id: string;\n    name: string;\n    username: string;\n    profileImage: string | null;\n    acceptedAt: string;\n  }>;\n  newRequests: Array<{\n    id: string;\n    name: string;\n    username: string;\n    profileImage: string | null;\n    sentAt: string;\n  }>;\n}\n\nexport interface RewardDataResponse {\n  hasNewMatches: boolean;\n  matches: MatchUser[];\n  hasTrendingSpike: boolean;\n  trendingData: TrendingData | null;\n  hasHiddenGems: boolean;\n  hiddenGems: MatchUser[];\n  hasNewMilestones: boolean;\n  milestones: MilestoneData[];\n  hasNewOpportunities: boolean;\n  opportunities: OpportunityData[];\n  hasNewViewers: boolean;\n  viewers: ViewerData[];\n  canGetSurpriseBoost: boolean;\n  surpriseBoostData: SurpriseBoostData | null;\n  hasConnectionUpdates: boolean;\n  connectionUpdates: ConnectionUpdateData | null;\n}\n\n// ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n// API FUNCTIONS\n// ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\nexport async function getRewardData(): Promise<RewardDataResponse> {\n  const res = await apiClient.get('/feed/reward-data');\n  return res.data.data;\n}\n\nexport async function markRewardShown(cardType: RewardCardType, itemIds: string[]): Promise<void> {\n  await apiClient.post('/feed/mark-shown', { cardType, itemIds });\n}\n"],"names":[],"mappings":";;;;;;AAAA;;AA+GO,eAAe;IACpB,MAAM,MAAM,MAAM,sIAAS,CAAC,GAAG,CAAC;IAChC,OAAO,IAAI,IAAI,CAAC,IAAI;AACtB;AAEO,eAAe,gBAAgB,QAAwB,EAAE,OAAiB;IAC/E,MAAM,sIAAS,CAAC,IAAI,CAAC,oBAAoB;QAAE;QAAU;IAAQ;AAC/D"}},
    {"offset": {"line": 704, "column": 0}, "map": {"version":3,"sources":["file:///home/yasmanth/Pictures/vormex/vormex-web/src/lib/api/notifications.ts"],"sourcesContent":["import apiClient from './client';\n\nexport type NotificationType =\n  | 'like'\n  | 'comment'\n  | 'comment_reply'\n  | 'mention'\n  | 'follow'\n  | 'connection_request'\n  | 'connection_accepted'\n  | 'reel_like'\n  | 'reel_comment'\n  | 'reel_comment_reply'\n  | 'reel_share'\n  | 'reel_mention'\n  | 'reel_view_milestone'\n  | 'message'\n  | 'streak_milestone'\n  | 'streak_lost'\n  | 'xp_earned'\n  | 'post_share'\n  // Legacy/Post types for compatibility\n  | 'POST_REACTION'\n  | 'POST_LIKE'\n  | 'COMMENT'\n  | 'COMMENT_LIKE'\n  | 'MENTION'\n  | 'CONNECTION_REQUEST'\n  | 'CONNECTION_ACCEPTED'\n  | 'POLL_VOTE'\n  | 'POST_SHARE'\n  | 'GROUP_INVITE'\n  | 'GROUP_JOIN_REQUEST'\n  | 'GROUP_JOIN_APPROVED';\n\nexport interface NotificationActor {\n  id: string;\n  username: string;\n  name: string;\n  profileImage: string | null;\n}\n\nexport interface NotificationPost {\n  id: string;\n  content: string;\n  mediaUrls: string[];\n}\n\nexport interface NotificationReel {\n  id: string;\n  title: string | null;\n  thumbnailUrl: string | null;\n  caption: string | null;\n}\n\nexport interface Notification {\n  id: string;\n  type: NotificationType;\n  title: string;\n  body: string;\n  actor: NotificationActor | null;\n  post: NotificationPost | null;\n  reel: NotificationReel | null;\n  data: Record<string, unknown> | null;\n  isRead: boolean;\n  readAt: string | null;\n  createdAt: string;\n  // Compatibility fields for Notifications component\n  content?: string;\n  postPreview?: string;\n  reactionType?: string | null;\n  postId?: string | null;\n  commentId?: string | null;\n  reelId?: string | null;\n}\n\nexport interface NotificationsResponse {\n  notifications: Notification[];\n  nextCursor: string | null;\n  hasMore: boolean;\n}\n\nexport interface NotificationSettings {\n  likes: boolean;\n  comments: boolean;\n  mentions: boolean;\n  follows: boolean;\n  reelLikes: boolean;\n  reelComments: boolean;\n  reelShares: boolean;\n  messages: boolean;\n  streaks: boolean;\n  email: boolean;\n  push: boolean;\n}\n\nexport const notificationsApi = {\n  getAll: (params?: { cursor?: string; limit?: number; unreadOnly?: boolean }) =>\n    apiClient.get<NotificationsResponse>('/notifications', { params }),\n\n  getUnreadCount: () =>\n    apiClient.get<{ count: number }>('/notifications/unread-count'),\n\n  markAsRead: (notificationIds: string[]) =>\n    apiClient.post<{ success: boolean }>('/notifications/read', { notificationIds }),\n\n  markAllAsRead: () =>\n    apiClient.post<{ success: boolean }>('/notifications/read-all'),\n\n  deleteNotification: (notificationId: string) =>\n    apiClient.delete<{ success: boolean }>(`/notifications/${notificationId}`),\n\n  getSettings: () =>\n    apiClient.get<{ settings: NotificationSettings }>('/notifications/settings'),\n};\n\n// Transform backend notification to component format\nfunction transformNotification(n: Notification): Notification {\n  const typeMap: Record<string, NotificationType> = {\n    like: 'POST_LIKE',\n    comment: 'COMMENT',\n    comment_reply: 'COMMENT_LIKE',\n    mention: 'MENTION',\n    follow: 'CONNECTION_ACCEPTED',\n    connection_request: 'CONNECTION_REQUEST',\n    connection_accepted: 'CONNECTION_ACCEPTED',\n    reel_like: 'POST_LIKE',\n    reel_comment: 'COMMENT',\n    reel_comment_reply: 'COMMENT_LIKE',\n    reel_share: 'POST_SHARE',\n    reel_mention: 'MENTION',\n    post_share: 'POST_SHARE',\n  };\n  const mappedType = typeMap[n.type] || n.type;\n  const data = n.data as Record<string, unknown> | null;\n  return {\n    ...n,\n    type: mappedType,\n    content: n.body,\n    postPreview: (data?.commentPreview as string) || (typeof n.body === 'string' ? n.body.slice(0, 50) : ''),\n    postId: n.post?.id ?? (data?.postId as string),\n    commentId: data?.commentId as string,\n    reelId: n.reel?.id ?? (data?.reelId as string),\n    reactionType: data?.reactionType as string,\n  };\n}\n\n/** Get notifications - for Notifications component */\nexport async function getNotifications(params?: { cursor?: string; limit?: number; unreadOnly?: boolean }) {\n  const data = (await apiClient.get('/notifications', { params })) as unknown as NotificationsResponse;\n  return {\n    notifications: data.notifications.map(transformNotification),\n    nextCursor: data.nextCursor,\n    hasMore: data.hasMore,\n  };\n}\n\n/** Get unread count - for Notifications component */\nexport async function getUnreadNotificationCount() {\n  return apiClient.get<{ count: number }>('/notifications/unread-count');\n}\n\n/** Mark notifications as read - for Notifications component */\nexport async function markNotificationsAsRead(notificationIds: string[]) {\n  await apiClient.post('/notifications/read', { notificationIds });\n}\n\n/** Mark all notifications as read - for Notifications component */\nexport async function markAllNotificationsAsRead() {\n  await apiClient.post('/notifications/read-all');\n}\n"],"names":[],"mappings":";;;;;;;;;;;;AAAA;;AAgGO,MAAM,mBAAmB;IAC9B,QAAQ,CAAC,SACP,sIAAS,CAAC,GAAG,CAAwB,kBAAkB;YAAE;QAAO;IAElE,gBAAgB,IACd,sIAAS,CAAC,GAAG,CAAoB;IAEnC,YAAY,CAAC,kBACX,sIAAS,CAAC,IAAI,CAAuB,uBAAuB;YAAE;QAAgB;IAEhF,eAAe,IACb,sIAAS,CAAC,IAAI,CAAuB;IAEvC,oBAAoB,CAAC,iBACnB,sIAAS,CAAC,MAAM,CAAuB,CAAC,eAAe,EAAE,gBAAgB;IAE3E,aAAa,IACX,sIAAS,CAAC,GAAG,CAAqC;AACtD;AAEA,qDAAqD;AACrD,SAAS,sBAAsB,CAAe;IAC5C,MAAM,UAA4C;QAChD,MAAM;QACN,SAAS;QACT,eAAe;QACf,SAAS;QACT,QAAQ;QACR,oBAAoB;QACpB,qBAAqB;QACrB,WAAW;QACX,cAAc;QACd,oBAAoB;QACpB,YAAY;QACZ,cAAc;QACd,YAAY;IACd;IACA,MAAM,aAAa,OAAO,CAAC,EAAE,IAAI,CAAC,IAAI,EAAE,IAAI;IAC5C,MAAM,OAAO,EAAE,IAAI;IACnB,OAAO;QACL,GAAG,CAAC;QACJ,MAAM;QACN,SAAS,EAAE,IAAI;QACf,aAAa,AAAC,MAAM,kBAA6B,CAAC,OAAO,EAAE,IAAI,KAAK,WAAW,EAAE,IAAI,CAAC,KAAK,CAAC,GAAG,MAAM,EAAE;QACvG,QAAQ,EAAE,IAAI,EAAE,MAAO,MAAM;QAC7B,WAAW,MAAM;QACjB,QAAQ,EAAE,IAAI,EAAE,MAAO,MAAM;QAC7B,cAAc,MAAM;IACtB;AACF;AAGO,eAAe,iBAAiB,MAAkE;IACvG,MAAM,OAAQ,MAAM,sIAAS,CAAC,GAAG,CAAC,kBAAkB;QAAE;IAAO;IAC7D,OAAO;QACL,eAAe,KAAK,aAAa,CAAC,GAAG,CAAC;QACtC,YAAY,KAAK,UAAU;QAC3B,SAAS,KAAK,OAAO;IACvB;AACF;AAGO,eAAe;IACpB,OAAO,sIAAS,CAAC,GAAG,CAAoB;AAC1C;AAGO,eAAe,wBAAwB,eAAyB;IACrE,MAAM,sIAAS,CAAC,IAAI,CAAC,uBAAuB;QAAE;IAAgB;AAChE;AAGO,eAAe;IACpB,MAAM,sIAAS,CAAC,IAAI,CAAC;AACvB"}},
    {"offset": {"line": 785, "column": 0}, "map": {"version":3,"sources":["file:///home/yasmanth/Pictures/vormex/vormex-web/src/lib/firebase.ts"],"sourcesContent":["import { initializeApp, getApps, type FirebaseApp } from 'firebase/app';\nimport { getMessaging, getToken, onMessage, isSupported, type Messaging } from 'firebase/messaging';\n\nconst firebaseConfig = {\n  apiKey: process.env.NEXT_PUBLIC_FIREBASE_API_KEY,\n  authDomain: process.env.NEXT_PUBLIC_FIREBASE_AUTH_DOMAIN,\n  projectId: process.env.NEXT_PUBLIC_FIREBASE_PROJECT_ID,\n  storageBucket: process.env.NEXT_PUBLIC_FIREBASE_STORAGE_BUCKET,\n  messagingSenderId: process.env.NEXT_PUBLIC_FIREBASE_MESSAGING_SENDER_ID,\n  appId: process.env.NEXT_PUBLIC_FIREBASE_APP_ID,\n};\n\nlet app: FirebaseApp | null = null;\nlet messaging: Messaging | null = null;\n\n/**\n * Initialize Firebase app (singleton, client-side only)\n */\nexport function getFirebaseApp(): FirebaseApp | null {\n  if (typeof window === 'undefined') return null;\n  if (!firebaseConfig.apiKey || !firebaseConfig.projectId) return null;\n\n  if (!app) {\n    app = getApps().length === 0 ? initializeApp(firebaseConfig) : getApps()[0];\n  }\n  return app;\n}\n\n/**\n * Get Firebase Cloud Messaging instance\n * Returns null if not supported (SSR, no permission, missing config)\n */\nexport async function getFirebaseMessaging(): Promise<Messaging | null> {\n  if (typeof window === 'undefined') return null;\n\n  const supported = await isSupported();\n  if (!supported) return null;\n\n  const firebaseApp = getFirebaseApp();\n  if (!firebaseApp) return null;\n\n  if (!messaging) {\n    messaging = getMessaging(firebaseApp);\n  }\n  return messaging;\n}\n\n/**\n * Request notification permission and get FCM token\n * Returns the token string, or null if denied/unsupported\n */\nexport async function requestNotificationToken(): Promise<string | null> {\n  try {\n    const permission = await Notification.requestPermission();\n    if (permission !== 'granted') return null;\n\n    const msg = await getFirebaseMessaging();\n    if (!msg) return null;\n\n    const vapidKey = process.env.NEXT_PUBLIC_FIREBASE_VAPID_KEY;\n    if (!vapidKey) {\n      console.warn('NEXT_PUBLIC_FIREBASE_VAPID_KEY not set');\n      return null;\n    }\n\n    const token = await getToken(msg, {\n      vapidKey,\n      serviceWorkerRegistration: await navigator.serviceWorker.register('/firebase-messaging-sw.js'),\n    });\n\n    return token;\n  } catch (err) {\n    console.error('Failed to get notification token:', err);\n    return null;\n  }\n}\n\n/**\n * Listen for foreground messages\n */\nexport function onForegroundMessage(callback: (payload: any) => void): (() => void) | null {\n  if (typeof window === 'undefined') return null;\n\n  getFirebaseMessaging().then(msg => {\n    if (!msg) return;\n    onMessage(msg, callback);\n  });\n\n  // Firebase onMessage doesn't return a clean unsubscribe for async init,\n  // so we return a no-op. The listener is tied to page lifecycle.\n  return () => {};\n}\n"],"names":[],"mappings":";;;;;;;;;;AAAA;AACA;AAAA;;;AAEA,MAAM,iBAAiB;IACrB,QAAQ,QAAQ,GAAG,CAAC,4BAA4B;IAChD,YAAY,QAAQ,GAAG,CAAC,gCAAgC;IACxD,WAAW,QAAQ,GAAG,CAAC,+BAA+B;IACtD,eAAe,QAAQ,GAAG,CAAC,mCAAmC;IAC9D,mBAAmB,QAAQ,GAAG,CAAC,wCAAwC;IACvE,OAAO,QAAQ,GAAG,CAAC,2BAA2B;AAChD;AAEA,IAAI,MAA0B;AAC9B,IAAI,YAA8B;AAK3B,SAAS;IACd,wCAAmC,OAAO;;;AAO5C;AAMO,eAAe;IACpB,wCAAmC,OAAO;;;IAE1C,MAAM;IAGN,MAAM;AAOR;AAMO,eAAe;IACpB,IAAI;QACF,MAAM,aAAa,MAAM,aAAa,iBAAiB;QACvD,IAAI,eAAe,WAAW,OAAO;QAErC,MAAM,MAAM,MAAM;QAClB,IAAI,CAAC,KAAK,OAAO;QAEjB,MAAM,WAAW,QAAQ,GAAG,CAAC,8BAA8B;QAC3D,IAAI,CAAC,UAAU;YACb,QAAQ,IAAI,CAAC;YACb,OAAO;QACT;QAEA,MAAM,QAAQ,MAAM,IAAA,kLAAQ,EAAC,KAAK;YAChC;YACA,2BAA2B,MAAM,UAAU,aAAa,CAAC,QAAQ,CAAC;QACpE;QAEA,OAAO;IACT,EAAE,OAAO,KAAK;QACZ,QAAQ,KAAK,CAAC,qCAAqC;QACnD,OAAO;IACT;AACF;AAKO,SAAS,oBAAoB,QAAgC;IAClE,wCAAmC,OAAO;;;AAU5C"}},
    {"offset": {"line": 852, "column": 0}, "map": {"version":3,"sources":["file:///home/yasmanth/Pictures/vormex/vormex-web/src/hooks/useRewards.ts"],"sourcesContent":["'use client';\n\nimport { useState, useEffect, useCallback } from 'react';\nimport { getStreaks, getWeeklyGoals, type StreakData, type WeeklyGoals } from '@/lib/api/engagement';\nimport { type RewardData } from '@/components/engagement/RewardPopup';\n\n/**\n * useRewards - Hook that checks for milestone achievements and queues reward popups\n * Mirrors Android's FeedRewardRepository logic\n */\n\nconst REWARDS_SHOWN_KEY = 'vormex_rewards_shown';\n\nfunction getShownRewards(): Set<string> {\n  try {\n    const stored = localStorage.getItem(REWARDS_SHOWN_KEY);\n    return stored ? new Set(JSON.parse(stored)) : new Set();\n  } catch {\n    return new Set();\n  }\n}\n\nfunction markRewardShown(id: string) {\n  try {\n    const shown = getShownRewards();\n    shown.add(id);\n    // Keep only last 100 to avoid localStorage bloat\n    const arr = Array.from(shown).slice(-100);\n    localStorage.setItem(REWARDS_SHOWN_KEY, JSON.stringify(arr));\n  } catch {\n    // localStorage not available\n  }\n}\n\nexport function useRewards(userId?: string) {\n  const [rewards, setRewards] = useState<RewardData[]>([]);\n\n  useEffect(() => {\n    if (!userId) return;\n\n    const checkMilestones = async () => {\n      const shown = getShownRewards();\n      const newRewards: RewardData[] = [];\n\n      try {\n        const [streakData, goalsData] = await Promise.all([\n          getStreaks().catch(() => null),\n          getWeeklyGoals().catch(() => null),\n        ]);\n\n        // Streak milestones (3, 5, 7, 10, 14, 21, 30, 50, 100 days)\n        if (streakData) {\n          const milestones = [3, 5, 7, 10, 14, 21, 30, 50, 100];\n          const streaks = [\n            { key: 'connection', value: streakData.connectionStreak, label: 'Networking' },\n            { key: 'login', value: streakData.loginStreak, label: 'Login' },\n            { key: 'posting', value: streakData.postingStreak, label: 'Posting' },\n            { key: 'messaging', value: streakData.messagingStreak, label: 'Messaging' },\n          ];\n\n          for (const s of streaks) {\n            for (const m of milestones) {\n              if (s.value === m) {\n                const id = `streak_${s.key}_${m}`;\n                if (!shown.has(id)) {\n                  newRewards.push({\n                    id,\n                    type: 'streak_milestone',\n                    title: `${m}-Day ${s.label} Streak! üî•`,\n                    message: `You've been consistent for ${m} days straight.`,\n                    value: `${m} days`,\n                    subtext: 'Keep it going!',\n                    showConfetti: m >= 7,\n                  });\n                }\n              }\n            }\n          }\n        }\n\n        // Weekly goals completed\n        if (goalsData?.isCompleted) {\n          const weekId = `weekly_goals_${new Date().toISOString().slice(0, 10)}`;\n          if (!shown.has(weekId)) {\n            newRewards.push({\n              id: weekId,\n              type: 'weekly_goal_complete',\n              title: 'Weekly Goals Complete! üéØ',\n              message: 'You crushed all your goals this week.',\n              subtext: 'New goals reset next Monday',\n              showConfetti: true,\n            });\n          }\n        }\n\n        // Limit to 2 popups per session\n        setRewards(newRewards.slice(0, 2));\n      } catch (error) {\n        console.error('Failed to check milestones:', error);\n      }\n    };\n\n    // Delay the check to not compete with feed loading\n    const timer = setTimeout(checkMilestones, 3000);\n    return () => clearTimeout(timer);\n  }, [userId]);\n\n  const dismissReward = useCallback((id: string) => {\n    markRewardShown(id);\n    setRewards(prev => prev.filter(r => r.id !== id));\n  }, []);\n\n  return { rewards, dismissReward };\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 989, "column": 0}, "map": {"version":3,"sources":["file:///home/yasmanth/Pictures/vormex/vormex-web/src/hooks/useVariableRewards.ts"],"sourcesContent":["'use client';\n\nimport { useState, useEffect, useCallback, useRef } from 'react';\nimport {\n  getRewardData,\n  markRewardShown,\n  type RewardDataResponse,\n  type RewardCardType,\n} from '@/lib/api/variable-rewards';\n\nexport interface ActiveRewardCard {\n  type: RewardCardType;\n  data: RewardDataResponse;\n  position: number; // insert after this post index\n}\n\n/**\n * useVariableRewards ‚Äî fetches reward data and determines which cards\n * to inject into the feed at variable-ratio positions.\n * Mirrors Android's RewardViewModel reward injection logic.\n */\nexport function useVariableRewards(userId: string | undefined) {\n  const [rewardData, setRewardData] = useState<RewardDataResponse | null>(null);\n  const [activeCards, setActiveCards] = useState<ActiveRewardCard[]>([]);\n  const [shownCardTypes, setShownCardTypes] = useState<Set<string>>(new Set());\n  const fetchedRef = useRef(false);\n\n  const fetchRewards = useCallback(async () => {\n    if (!userId || fetchedRef.current) return;\n    fetchedRef.current = true;\n\n    try {\n      const data = await getRewardData();\n      setRewardData(data);\n\n      // Determine which cards to show (variable-ratio: not all at once)\n      const available: { type: RewardCardType; priority: number }[] = [];\n\n      if (data.hasNewMatches && data.matches.length > 0)\n        available.push({ type: 'MATCH_BURST', priority: 1 });\n      if (data.hasTrendingSpike && data.trendingData?.hasSpike)\n        available.push({ type: 'TRENDING', priority: 2 });\n      if (data.hasHiddenGems && data.hiddenGems.length > 0)\n        available.push({ type: 'HIDDEN_GEM', priority: 3 });\n      if (data.hasNewMilestones && data.milestones.length > 0)\n        available.push({ type: 'MILESTONE', priority: 0 }); // highest priority\n      if (data.hasNewOpportunities && data.opportunities.length > 0)\n        available.push({ type: 'OPPORTUNITY', priority: 5 });\n      if (data.hasNewViewers && data.viewers.length > 0)\n        available.push({ type: 'SOCIAL_PROOF', priority: 4 });\n      if (data.canGetSurpriseBoost && data.surpriseBoostData?.eligible)\n        available.push({ type: 'SURPRISE_BOOST', priority: 0 });\n      if (data.hasConnectionUpdates && data.connectionUpdates?.hasUpdates)\n        available.push({ type: 'CONNECTION_UPDATE', priority: 2 });\n\n      // Sort by priority, pick up to 3 cards per session (variable ratio)\n      available.sort((a, b) => a.priority - b.priority);\n      const maxCards = Math.min(available.length, 3);\n      const selected = available.slice(0, maxCards);\n\n      // Assign positions: after post 3, 7, 12 (variable spacing)\n      const positions = [3, 7, 12];\n      const cards: ActiveRewardCard[] = selected.map((s, i) => ({\n        type: s.type,\n        data,\n        position: positions[i] || positions[positions.length - 1] + (i * 4),\n      }));\n\n      // Check localStorage for already-shown deduplication\n      const shownKey = `rewards_shown_${new Date().toISOString().slice(0, 10)}`;\n      const alreadyShown = new Set<string>(\n        JSON.parse(localStorage.getItem(shownKey) || '[]')\n      );\n      const filtered = cards.filter(c => !alreadyShown.has(c.type));\n      setActiveCards(filtered);\n      setShownCardTypes(alreadyShown);\n    } catch (err) {\n      console.error('Failed to fetch reward data:', err);\n    }\n  }, [userId]);\n\n  useEffect(() => {\n    fetchRewards();\n  }, [fetchRewards]);\n\n  const dismissCard = useCallback(async (type: RewardCardType, itemIds: string[] = []) => {\n    setActiveCards(prev => prev.filter(c => c.type !== type));\n\n    // Persist to localStorage\n    const shownKey = `rewards_shown_${new Date().toISOString().slice(0, 10)}`;\n    const current = new Set<string>(\n      JSON.parse(localStorage.getItem(shownKey) || '[]')\n    );\n    current.add(type);\n    localStorage.setItem(shownKey, JSON.stringify([...current]));\n\n    // Notify backend\n    try {\n      await markRewardShown(type, itemIds);\n    } catch {\n      // silent ‚Äî non-critical\n    }\n  }, []);\n\n  return { rewardData, activeCards, dismissCard };\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1101, "column": 0}, "map": {"version":3,"sources":["file:///home/yasmanth/Pictures/vormex/vormex-web/src/hooks/usePushNotifications.ts"],"sourcesContent":["'use client';\n\nimport { useState, useEffect, useCallback, useRef } from 'react';\nimport { requestNotificationToken, onForegroundMessage } from '@/lib/firebase';\nimport apiClient from '@/lib/api/client';\n\ninterface PushNotificationState {\n  isSupported: boolean;\n  isPermissionGranted: boolean;\n  isTokenRegistered: boolean;\n  isLoading: boolean;\n}\n\n/**\n * usePushNotifications ‚Äî manages web push notification lifecycle\n * 1. Checks browser support\n * 2. Requests permission\n * 3. Gets FCM token\n * 4. Registers token with backend via POST /api/devices/register\n * 5. Listens for foreground messages\n */\nexport function usePushNotifications(userId: string | undefined) {\n  const [state, setState] = useState<PushNotificationState>({\n    isSupported: false,\n    isPermissionGranted: false,\n    isTokenRegistered: false,\n    isLoading: false,\n  });\n  const [foregroundNotification, setForegroundNotification] = useState<any>(null);\n  const registeredRef = useRef(false);\n  const tokenRef = useRef<string | null>(null);\n\n  // Check support on mount\n  useEffect(() => {\n    if (typeof window === 'undefined') return;\n\n    const supported = 'Notification' in window && 'serviceWorker' in navigator;\n    const granted = supported && Notification.permission === 'granted';\n\n    setState(prev => ({\n      ...prev,\n      isSupported: supported,\n      isPermissionGranted: granted,\n    }));\n\n    // If already granted + user logged in, register silently\n    if (granted && userId && !registeredRef.current) {\n      registerToken();\n    }\n  }, [userId]);\n\n  // Listen for foreground messages\n  useEffect(() => {\n    if (!state.isPermissionGranted) return;\n\n    const unsubscribe = onForegroundMessage((payload) => {\n      setForegroundNotification(payload);\n\n      // Auto-dismiss after 5s\n      setTimeout(() => setForegroundNotification(null), 5000);\n    });\n\n    return () => {\n      if (unsubscribe) unsubscribe();\n    };\n  }, [state.isPermissionGranted]);\n\n  const registerToken = useCallback(async () => {\n    if (registeredRef.current || state.isLoading) return;\n\n    setState(prev => ({ ...prev, isLoading: true }));\n\n    try {\n      const token = await requestNotificationToken();\n      if (!token) {\n        setState(prev => ({ ...prev, isLoading: false }));\n        return;\n      }\n\n      // Register with backend\n      await apiClient.post('/devices/register', {\n        token,\n        platform: 'web',\n        deviceId: `web-${navigator.userAgent.slice(0, 50)}`,\n      });\n\n      registeredRef.current = true;\n      tokenRef.current = token;\n      setState(prev => ({\n        ...prev,\n        isPermissionGranted: true,\n        isTokenRegistered: true,\n        isLoading: false,\n      }));\n\n      // Store in localStorage to avoid re-registering\n      localStorage.setItem('push_token_registered', 'true');\n    } catch (err) {\n      console.error('Push notification registration failed:', err);\n      setState(prev => ({ ...prev, isLoading: false }));\n    }\n  }, [state.isLoading]);\n\n  const requestPermission = useCallback(async (): Promise<boolean> => {\n    if (!state.isSupported) return false;\n\n    setState(prev => ({ ...prev, isLoading: true }));\n\n    try {\n      const permission = await Notification.requestPermission();\n      if (permission === 'granted') {\n        setState(prev => ({ ...prev, isPermissionGranted: true }));\n        await registerToken();\n        setState(prev => ({ ...prev, isLoading: false }));\n        return registeredRef.current;\n      } else {\n        setState(prev => ({ ...prev, isLoading: false }));\n        return false;\n      }\n    } catch {\n      setState(prev => ({ ...prev, isLoading: false }));\n      return false;\n    }\n  }, [state.isSupported, registerToken]);\n\n  const dismissNotification = useCallback(() => {\n    setForegroundNotification(null);\n  }, []);\n\n  const subscribe = useCallback(async (): Promise<boolean> => {\n    return requestPermission();\n  }, [requestPermission]);\n\n  const unsubscribe = useCallback(async () => {\n    const token = tokenRef.current;\n    if (!token) return;\n    try {\n      await apiClient.delete('/devices/unregister', { data: { token } });\n      registeredRef.current = false;\n      tokenRef.current = null;\n      localStorage.removeItem('push_token_registered');\n      setState(prev => ({\n        ...prev,\n        isTokenRegistered: false,\n        isPermissionGranted: false,\n      }));\n    } catch (err) {\n      console.error('Push notification unregister failed:', err);\n    }\n  }, []);\n\n  return {\n    ...state,\n    isSubscribed: state.isTokenRegistered,\n    foregroundNotification,\n    requestPermission,\n    dismissNotification,\n    subscribe,\n    unsubscribe,\n  };\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1267, "column": 0}, "map": {"version":3,"sources":["file:///home/yasmanth/Pictures/vormex/vormex-web/src/app/page.tsx"],"sourcesContent":["'use client';\n\nimport { ProtectedRoute } from '@/components/auth/ProtectedRoute';\nimport { Feed } from '@/components/feed';\n\nexport default function Home() {\n  return (\n    <ProtectedRoute>\n      <div className=\"min-h-screen bg-gray-50 dark:bg-neutral-950\">\n        <Feed />\n      </div>\n    </ProtectedRoute>\n  );\n}\n"],"names":[],"mappings":";;;;;AAEA;AACA;AAAA;AAHA;;;;AAKe,SAAS;IACtB,qBACE,8OAAC,8JAAc;kBACb,cAAA,8OAAC;YAAI,WAAU;sBACb,cAAA,8OAAC,0IAAI;;;;;;;;;;;;;;;AAIb"}}]
}
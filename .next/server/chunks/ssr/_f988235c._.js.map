{"version":3,"sources":["../../../../node_modules/lucide-react/src/icons/arrow-left.ts","../../../../src/hooks/reels/useReelsFeed.ts","../../../../src/hooks/reels/useReelPlayer.ts","../../../../src/hooks/reels/useReelEngagement.ts","../../../../src/hooks/reels/useReelPreload.ts","../../../../src/hooks/reels/useReelRealtime.ts","../../../../src/app/reels/hashtag/%5Btag%5D/page.tsx"],"sourcesContent":["import createLucideIcon from '../createLucideIcon';\n\n/**\n * @component @name ArrowLeft\n * @description Lucide SVG icon component, renders SVG Element with children.\n *\n * @preview ![img](data:image/svg+xml;base64,PHN2ZyAgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogIHdpZHRoPSIyNCIKICBoZWlnaHQ9IjI0IgogIHZpZXdCb3g9IjAgMCAyNCAyNCIKICBmaWxsPSJub25lIgogIHN0cm9rZT0iIzAwMCIgc3R5bGU9ImJhY2tncm91bmQtY29sb3I6ICNmZmY7IGJvcmRlci1yYWRpdXM6IDJweCIKICBzdHJva2Utd2lkdGg9IjIiCiAgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIgogIHN0cm9rZS1saW5lam9pbj0icm91bmQiCj4KICA8cGF0aCBkPSJtMTIgMTktNy03IDctNyIgLz4KICA8cGF0aCBkPSJNMTkgMTJINSIgLz4KPC9zdmc+Cg==) - https://lucide.dev/icons/arrow-left\n * @see https://lucide.dev/guide/packages/lucide-react - Documentation\n *\n * @param {Object} props - Lucide icons props and any valid SVG attribute\n * @returns {JSX.Element} JSX Element\n *\n */\nconst ArrowLeft = createLucideIcon('ArrowLeft', [\n  ['path', { d: 'm12 19-7-7 7-7', key: '1l729n' }],\n  ['path', { d: 'M19 12H5', key: 'x3x0zl' }],\n]);\n\nexport default ArrowLeft;\n","'use client';\n\nimport { useInfiniteQuery } from '@tanstack/react-query';\nimport { reelsApi, Reel, ReelsFeedResponse } from '@/lib/api/reels';\n\ninterface UseReelsFeedOptions {\n  mode?: 'foryou' | 'following';\n  initialData?: Reel[];\n  enabled?: boolean;\n}\n\nexport function useReelsFeed({\n  mode = 'foryou',\n  initialData,\n  enabled = true,\n}: UseReelsFeedOptions = {}) {\n  const query = useInfiniteQuery({\n    queryKey: ['reels-feed', mode],\n    queryFn: async ({ pageParam }) => {\n      const response = await reelsApi.getFeed({ cursor: pageParam, limit: 10, mode });\n      return response as unknown as ReelsFeedResponse;\n    },\n    getNextPageParam: (lastPage) => lastPage.nextCursor,\n    initialPageParam: undefined as string | undefined,\n    staleTime: 1000 * 60 * 5,\n    enabled,\n    initialData: initialData\n      ? {\n          pages: [{ reels: initialData, nextCursor: null, hasMore: false }],\n          pageParams: [undefined],\n        }\n      : undefined,\n  });\n\n  const reels = query.data?.pages.flatMap((p) => p.reels) ?? [];\n\n  return {\n    reels,\n    isLoading: query.isLoading,\n    isError: query.isError,\n    error: query.error,\n    hasNextPage: query.hasNextPage,\n    isFetchingNextPage: query.isFetchingNextPage,\n    fetchNextPage: query.fetchNextPage,\n    refetch: query.refetch,\n  };\n}\n\nexport function useTrendingReels(hours: number = 24) {\n  const query = useInfiniteQuery({\n    queryKey: ['reels-trending', hours],\n    queryFn: async () => {\n      const response = await reelsApi.getTrending({ hours, limit: 20 });\n      return response as unknown as ReelsFeedResponse;\n    },\n    getNextPageParam: () => undefined,\n    initialPageParam: undefined,\n    staleTime: 1000 * 60 * 5,\n  });\n\n  const reels = query.data?.pages.flatMap((p) => p.reels) ?? [];\n\n  return {\n    reels,\n    isLoading: query.isLoading,\n    isError: query.isError,\n    refetch: query.refetch,\n  };\n}\n\nexport function useHashtagReels(hashtag: string) {\n  const query = useInfiniteQuery({\n    queryKey: ['reels-hashtag', hashtag],\n    queryFn: async ({ pageParam }) => {\n      const response = await reelsApi.getByHashtag(hashtag, { cursor: pageParam, limit: 20 });\n      return response as unknown as ReelsFeedResponse;\n    },\n    getNextPageParam: (lastPage) => lastPage.nextCursor,\n    initialPageParam: undefined as string | undefined,\n    staleTime: 1000 * 60 * 5,\n    enabled: !!hashtag,\n  });\n\n  const reels = query.data?.pages.flatMap((p) => p.reels) ?? [];\n\n  return {\n    reels,\n    isLoading: query.isLoading,\n    isError: query.isError,\n    hasNextPage: query.hasNextPage,\n    isFetchingNextPage: query.isFetchingNextPage,\n    fetchNextPage: query.fetchNextPage,\n    refetch: query.refetch,\n  };\n}\n\nexport function useAudioReels(audioId: string) {\n  const query = useInfiniteQuery({\n    queryKey: ['reels-audio', audioId],\n    queryFn: async ({ pageParam }) => {\n      const response = await reelsApi.getByAudio(audioId, { cursor: pageParam, limit: 20 });\n      return response as unknown as ReelsFeedResponse;\n    },\n    getNextPageParam: (lastPage) => lastPage.nextCursor,\n    initialPageParam: undefined as string | undefined,\n    staleTime: 1000 * 60 * 5,\n    enabled: !!audioId,\n  });\n\n  const reels = query.data?.pages.flatMap((p) => p.reels) ?? [];\n\n  return {\n    reels,\n    isLoading: query.isLoading,\n    isError: query.isError,\n    hasNextPage: query.hasNextPage,\n    isFetchingNextPage: query.isFetchingNextPage,\n    fetchNextPage: query.fetchNextPage,\n    refetch: query.refetch,\n  };\n}\n\nexport function useUserReels(userId: string) {\n  const query = useInfiniteQuery({\n    queryKey: ['reels-user', userId],\n    queryFn: async ({ pageParam }) => {\n      const response = await reelsApi.getUserReels(userId, { cursor: pageParam, limit: 20 });\n      return response as unknown as ReelsFeedResponse;\n    },\n    getNextPageParam: (lastPage) => lastPage.nextCursor,\n    initialPageParam: undefined as string | undefined,\n    staleTime: 1000 * 60 * 5,\n    enabled: !!userId,\n  });\n\n  const reels = query.data?.pages.flatMap((p) => p.reels) ?? [];\n\n  return {\n    reels,\n    isLoading: query.isLoading,\n    isError: query.isError,\n    hasNextPage: query.hasNextPage,\n    isFetchingNextPage: query.isFetchingNextPage,\n    fetchNextPage: query.fetchNextPage,\n    refetch: query.refetch,\n  };\n}\n","'use client';\n\nimport { useState, useCallback, useRef, useEffect } from 'react';\nimport Hls from 'hls.js';\n\ninterface UseReelPlayerOptions {\n  hlsUrl: string | null;\n  mp4Url: string;\n  autoPlay?: boolean;\n  muted?: boolean;\n  loop?: boolean;\n}\n\ninterface UseReelPlayerReturn {\n  videoRef: React.RefObject<HTMLVideoElement>;\n  isLoaded: boolean;\n  isPlaying: boolean;\n  isMuted: boolean;\n  progress: number;\n  duration: number;\n  currentTime: number;\n  error: Error | null;\n  play: () => Promise<void>;\n  pause: () => void;\n  togglePlay: () => void;\n  toggleMute: () => void;\n  seek: (time: number) => void;\n  setVolume: (volume: number) => void;\n}\n\nexport function useReelPlayer({\n  hlsUrl,\n  mp4Url,\n  autoPlay = false,\n  muted = true,\n  loop = true,\n}: UseReelPlayerOptions): UseReelPlayerReturn {\n  const videoRef = useRef<HTMLVideoElement>(null);\n  const hlsRef = useRef<Hls | null>(null);\n  const [isLoaded, setIsLoaded] = useState(false);\n  const [isPlaying, setIsPlaying] = useState(false);\n  const [isMuted, setIsMuted] = useState(muted);\n  const [progress, setProgress] = useState(0);\n  const [duration, setDuration] = useState(0);\n  const [currentTime, setCurrentTime] = useState(0);\n  const [error, setError] = useState<Error | null>(null);\n\n  useEffect(() => {\n    const video = videoRef.current;\n    if (!video) return;\n\n    const initHls = () => {\n      if (hlsUrl && Hls.isSupported()) {\n        const hls = new Hls({\n          enableWorker: true,\n          lowLatencyMode: true,\n          backBufferLength: 90,\n          maxBufferLength: 30,\n          maxMaxBufferLength: 60,\n          startLevel: -1,\n          capLevelToPlayerSize: true,\n        });\n\n        hls.loadSource(hlsUrl);\n        hls.attachMedia(video);\n\n        hls.on(Hls.Events.MANIFEST_PARSED, () => {\n          setIsLoaded(true);\n          setError(null);\n          if (autoPlay) {\n            video.play().catch(() => {});\n          }\n        });\n\n        hls.on(Hls.Events.ERROR, (_, data) => {\n          if (data.fatal) {\n            console.error('HLS error:', data);\n            setError(new Error('HLS playback failed'));\n            video.src = mp4Url;\n            video.load();\n          }\n        });\n\n        hlsRef.current = hls;\n      } else if (hlsUrl && video.canPlayType('application/vnd.apple.mpegurl')) {\n        video.src = hlsUrl;\n      } else {\n        video.src = mp4Url;\n      }\n    };\n\n    const handleLoadedMetadata = () => {\n      setIsLoaded(true);\n      setDuration(video.duration);\n      if (autoPlay) {\n        video.play().catch(() => {});\n      }\n    };\n\n    const handleTimeUpdate = () => {\n      setCurrentTime(video.currentTime);\n      setProgress(video.duration > 0 ? video.currentTime / video.duration : 0);\n    };\n\n    const handlePlay = () => setIsPlaying(true);\n    const handlePause = () => setIsPlaying(false);\n    const handleEnded = () => {\n      if (loop) {\n        video.currentTime = 0;\n        video.play().catch(() => {});\n      }\n    };\n    const handleError = () => {\n      setError(new Error('Video playback error'));\n    };\n\n    video.addEventListener('loadedmetadata', handleLoadedMetadata);\n    video.addEventListener('timeupdate', handleTimeUpdate);\n    video.addEventListener('play', handlePlay);\n    video.addEventListener('pause', handlePause);\n    video.addEventListener('ended', handleEnded);\n    video.addEventListener('error', handleError);\n\n    initHls();\n\n    return () => {\n      video.removeEventListener('loadedmetadata', handleLoadedMetadata);\n      video.removeEventListener('timeupdate', handleTimeUpdate);\n      video.removeEventListener('play', handlePlay);\n      video.removeEventListener('pause', handlePause);\n      video.removeEventListener('ended', handleEnded);\n      video.removeEventListener('error', handleError);\n      hlsRef.current?.destroy();\n      hlsRef.current = null;\n    };\n  }, [hlsUrl, mp4Url, autoPlay, loop]);\n\n  useEffect(() => {\n    if (videoRef.current) {\n      videoRef.current.muted = isMuted;\n    }\n  }, [isMuted]);\n\n  const play = useCallback(async () => {\n    if (videoRef.current) {\n      await videoRef.current.play();\n    }\n  }, []);\n\n  const pause = useCallback(() => {\n    if (videoRef.current) {\n      videoRef.current.pause();\n    }\n  }, []);\n\n  const togglePlay = useCallback(() => {\n    if (isPlaying) {\n      pause();\n    } else {\n      play();\n    }\n  }, [isPlaying, play, pause]);\n\n  const toggleMute = useCallback(() => {\n    setIsMuted((prev) => !prev);\n  }, []);\n\n  const seek = useCallback((time: number) => {\n    if (videoRef.current) {\n      videoRef.current.currentTime = time;\n    }\n  }, []);\n\n  const setVolume = useCallback((volume: number) => {\n    if (videoRef.current) {\n      videoRef.current.volume = Math.max(0, Math.min(1, volume));\n    }\n  }, []);\n\n  return {\n    videoRef: videoRef as React.RefObject<HTMLVideoElement>,\n    isLoaded,\n    isPlaying,\n    isMuted,\n    progress,\n    duration,\n    currentTime,\n    error,\n    play,\n    pause,\n    togglePlay,\n    toggleMute,\n    seek,\n    setVolume,\n  };\n}\n","'use client';\n\nimport { useState, useCallback } from 'react';\nimport { reelsApi, Reel } from '@/lib/api/reels';\n\ninterface UseReelEngagementReturn {\n  isLiked: boolean;\n  isSaved: boolean;\n  likesCount: number;\n  savesCount: number;\n  toggleLike: () => Promise<void>;\n  toggleSave: () => Promise<void>;\n  share: (type?: string) => Promise<void>;\n  isLiking: boolean;\n  isSaving: boolean;\n  isSharing: boolean;\n}\n\nexport function useReelEngagement(reel: Reel): UseReelEngagementReturn {\n  const [isLiked, setIsLiked] = useState(reel.isLiked);\n  const [isSaved, setIsSaved] = useState(reel.isSaved);\n  const [likesCount, setLikesCount] = useState(reel.likesCount);\n  const [savesCount, setSavesCount] = useState(reel.savesCount);\n  const [isLiking, setIsLiking] = useState(false);\n  const [isSaving, setIsSaving] = useState(false);\n  const [isSharing, setIsSharing] = useState(false);\n\n  const toggleLike = useCallback(async () => {\n    if (isLiking) return;\n\n    const prevLiked = isLiked;\n    const prevCount = likesCount;\n\n    setIsLiked(!prevLiked);\n    setLikesCount(prevLiked ? prevCount - 1 : prevCount + 1);\n    setIsLiking(true);\n\n    try {\n      const response = (await reelsApi.toggleLike(reel.id)) as unknown as { liked: boolean; likesCount: number };\n      setIsLiked(response.liked);\n      setLikesCount(response.likesCount);\n    } catch (error) {\n      console.error('Failed to toggle like:', error);\n      setIsLiked(prevLiked);\n      setLikesCount(prevCount);\n    } finally {\n      setIsLiking(false);\n    }\n  }, [reel.id, isLiked, likesCount, isLiking]);\n\n  const toggleSave = useCallback(async () => {\n    if (isSaving) return;\n\n    const prevSaved = isSaved;\n    const prevCount = savesCount;\n\n    setIsSaved(!prevSaved);\n    setSavesCount(prevSaved ? prevCount - 1 : prevCount + 1);\n    setIsSaving(true);\n\n    try {\n      const response = (await reelsApi.toggleSave(reel.id)) as unknown as { saved: boolean; savesCount: number };\n      setIsSaved(response.saved);\n      setSavesCount(response.savesCount);\n    } catch (error) {\n      console.error('Failed to toggle save:', error);\n      setIsSaved(prevSaved);\n      setSavesCount(prevCount);\n    } finally {\n      setIsSaving(false);\n    }\n  }, [reel.id, isSaved, savesCount, isSaving]);\n\n  const share = useCallback(async (type: string = 'copy_link') => {\n    if (isSharing) return;\n\n    setIsSharing(true);\n\n    try {\n      const url = `${window.location.origin}/reels/${reel.id}`;\n\n      if (type === 'native' && navigator.share) {\n        await navigator.share({\n          title: reel.title || 'Check out this reel',\n          text: reel.caption || '',\n          url,\n        });\n        await reelsApi.share(reel.id, { shareType: 'external' });\n      } else {\n        await navigator.clipboard.writeText(url);\n        await reelsApi.share(reel.id, { shareType: 'copy_link' });\n      }\n    } catch (error) {\n      if ((error as Error).name !== 'AbortError') {\n        console.error('Failed to share:', error);\n      }\n    } finally {\n      setIsSharing(false);\n    }\n  }, [reel.id, reel.title, reel.caption, isSharing]);\n\n  return {\n    isLiked,\n    isSaved,\n    likesCount,\n    savesCount,\n    toggleLike,\n    toggleSave,\n    share,\n    isLiking,\n    isSaving,\n    isSharing,\n  };\n}\n","'use client';\n\nimport { useEffect, useRef, useCallback } from 'react';\nimport { reelsApi, Reel } from '@/lib/api/reels';\n\ninterface UseReelPreloadOptions {\n  reels: Reel[];\n  activeIndex: number;\n  preloadCount?: number;\n}\n\nexport function useReelPreload({\n  reels,\n  activeIndex,\n  preloadCount = 3,\n}: UseReelPreloadOptions) {\n  const preloadedUrls = useRef<Set<string>>(new Set());\n  const preloadedImages = useRef<Set<string>>(new Set());\n\n  const preloadHls = useCallback(async (url: string) => {\n    if (preloadedUrls.current.has(url)) return;\n    \n    try {\n      await fetch(url, { method: 'HEAD' });\n      preloadedUrls.current.add(url);\n    } catch (error) {\n      // Ignore errors\n    }\n  }, []);\n\n  const preloadThumbnail = useCallback((url: string) => {\n    if (preloadedImages.current.has(url)) return;\n    \n    const img = new Image();\n    img.src = url;\n    img.onload = () => {\n      preloadedImages.current.add(url);\n    };\n  }, []);\n\n  useEffect(() => {\n    const reelsToPreload = reels.slice(activeIndex + 1, activeIndex + 1 + preloadCount);\n\n    reelsToPreload.forEach((reel) => {\n      if (reel.hlsUrl) {\n        preloadHls(reel.hlsUrl);\n      }\n      if (reel.thumbnailUrl) {\n        preloadThumbnail(reel.thumbnailUrl);\n      }\n    });\n  }, [activeIndex, reels, preloadCount, preloadHls, preloadThumbnail]);\n\n  const preloadReel = useCallback(async (reelId: string) => {\n    try {\n      const data = await reelsApi.getPreloadData(reelId);\n      const preloadData = data as unknown as { hlsUrl: string; thumbnailUrl: string };\n      if (preloadData.hlsUrl) {\n        preloadHls(preloadData.hlsUrl);\n      }\n      if (preloadData.thumbnailUrl) {\n        preloadThumbnail(preloadData.thumbnailUrl);\n      }\n    } catch (error) {\n      // Ignore errors\n    }\n  }, [preloadHls, preloadThumbnail]);\n\n  const clearCache = useCallback(() => {\n    preloadedUrls.current.clear();\n    preloadedImages.current.clear();\n  }, []);\n\n  return {\n    preloadReel,\n    clearCache,\n    preloadedCount: preloadedUrls.current.size,\n  };\n}\n","'use client';\n\nimport { useEffect, useCallback, useRef } from 'react';\nimport { \n  getSocket, \n  initializeSocket, \n  joinReelRoom, \n  leaveReelRoom \n} from '@/lib/socket';\nimport { Reel } from '@/lib/api/reels';\n\ninterface ReelEngagementUpdate {\n  reelId: string;\n  type: 'like' | 'comment' | 'share';\n  userId?: string;\n  liked?: boolean;\n  likesCount?: number;\n  commentsCount?: number;\n  sharesCount?: number;\n  comment?: {\n    id: string;\n    author: {\n      id: string;\n      username: string;\n      name: string;\n      profileImage: string | null;\n    };\n    content: string;\n    parentId?: string;\n  };\n}\n\ninterface UseReelRealtimeOptions {\n  reelId: string;\n  onEngagementUpdate?: (update: ReelEngagementUpdate) => void;\n  onNewComment?: (comment: ReelEngagementUpdate['comment']) => void;\n  enabled?: boolean;\n}\n\nexport function useReelRealtime({\n  reelId,\n  onEngagementUpdate,\n  onNewComment,\n  enabled = true,\n}: UseReelRealtimeOptions) {\n  const handlersRef = useRef({ onEngagementUpdate, onNewComment });\n  \n  useEffect(() => {\n    handlersRef.current = { onEngagementUpdate, onNewComment };\n  }, [onEngagementUpdate, onNewComment]);\n\n  useEffect(() => {\n    if (!enabled || !reelId) return;\n\n    const socket = getSocket() || initializeSocket();\n    \n    // Join reel room\n    joinReelRoom(reelId);\n\n    // Handle engagement updates\n    const handleEngagementUpdate = (data: ReelEngagementUpdate) => {\n      if (data.reelId !== reelId) return;\n      \n      handlersRef.current.onEngagementUpdate?.(data);\n      \n      if (data.type === 'comment' && data.comment) {\n        handlersRef.current.onNewComment?.(data.comment);\n      }\n    };\n\n    socket?.on('reel:engagement_update', handleEngagementUpdate);\n\n    return () => {\n      leaveReelRoom(reelId);\n      socket?.off('reel:engagement_update', handleEngagementUpdate);\n    };\n  }, [reelId, enabled]);\n}\n\ninterface UseReelsFeedRealtimeOptions {\n  reelIds: string[];\n  onReelUpdate?: (reelId: string, updates: Partial<Reel>) => void;\n  enabled?: boolean;\n}\n\nexport function useReelsFeedRealtime({\n  reelIds,\n  onReelUpdate,\n  enabled = true,\n}: UseReelsFeedRealtimeOptions) {\n  const handlersRef = useRef({ onReelUpdate });\n  const joinedRoomsRef = useRef<Set<string>>(new Set());\n\n  useEffect(() => {\n    handlersRef.current = { onReelUpdate };\n  }, [onReelUpdate]);\n\n  useEffect(() => {\n    if (!enabled || reelIds.length === 0) return;\n\n    const socket = getSocket() || initializeSocket();\n\n    // Join rooms for new reels\n    reelIds.forEach((reelId) => {\n      if (!joinedRoomsRef.current.has(reelId)) {\n        joinReelRoom(reelId);\n        joinedRoomsRef.current.add(reelId);\n      }\n    });\n\n    // Leave rooms for reels no longer in view\n    joinedRoomsRef.current.forEach((reelId) => {\n      if (!reelIds.includes(reelId)) {\n        leaveReelRoom(reelId);\n        joinedRoomsRef.current.delete(reelId);\n      }\n    });\n\n    // Handle engagement updates\n    const handleEngagementUpdate = (data: ReelEngagementUpdate) => {\n      if (!reelIds.includes(data.reelId)) return;\n\n      const updates: Partial<Reel> = {};\n      \n      if (data.type === 'like' && data.likesCount !== undefined) {\n        updates.likesCount = data.likesCount;\n      }\n      if (data.type === 'comment' && data.commentsCount !== undefined) {\n        updates.commentsCount = data.commentsCount;\n      }\n      if (data.type === 'share' && data.sharesCount !== undefined) {\n        updates.sharesCount = data.sharesCount;\n      }\n\n      if (Object.keys(updates).length > 0) {\n        handlersRef.current.onReelUpdate?.(data.reelId, updates);\n      }\n    };\n\n    socket?.on('reel:engagement_update', handleEngagementUpdate);\n\n    return () => {\n      // Leave all rooms on unmount\n      joinedRoomsRef.current.forEach((reelId) => {\n        leaveReelRoom(reelId);\n      });\n      joinedRoomsRef.current.clear();\n      socket?.off('reel:engagement_update', handleEngagementUpdate);\n    };\n  }, [reelIds, enabled]);\n}\n","'use client';\n\nimport { useState, useCallback } from 'react';\nimport { useParams, useRouter } from 'next/navigation';\nimport { ArrowLeft, Hash, Loader2 } from 'lucide-react';\nimport { useHashtagReels } from '@/hooks/reels';\nimport { ReelCard } from '@/components/reels';\n\nexport default function HashtagReelsPage() {\n  const params = useParams();\n  const router = useRouter();\n  const hashtag = decodeURIComponent(params.tag as string);\n  \n  const [activeIndex, setActiveIndex] = useState(0);\n  const [isMuted, setIsMuted] = useState(true);\n  \n  const { reels, isLoading, isError, hasNextPage, isFetchingNextPage, fetchNextPage } = useHashtagReels(hashtag);\n\n  const handleScroll = useCallback((e: React.UIEvent<HTMLDivElement>) => {\n    const container = e.currentTarget;\n    const scrollTop = container.scrollTop;\n    const itemHeight = container.clientHeight;\n    const newIndex = Math.round(scrollTop / itemHeight);\n\n    if (newIndex !== activeIndex) {\n      setActiveIndex(newIndex);\n\n      if (newIndex >= reels.length - 3 && hasNextPage && !isFetchingNextPage) {\n        fetchNextPage();\n      }\n    }\n  }, [activeIndex, reels.length, hasNextPage, isFetchingNextPage, fetchNextPage]);\n\n  if (isLoading) {\n    return (\n      <div className=\"h-screen w-full flex items-center justify-center bg-black\">\n        <Loader2 className=\"w-12 h-12 text-white animate-spin\" />\n      </div>\n    );\n  }\n\n  if (isError) {\n    return (\n      <div className=\"h-screen w-full flex flex-col items-center justify-center bg-black text-white gap-4\">\n        <p>Failed to load reels</p>\n        <button\n          onClick={() => window.location.reload()}\n          className=\"px-4 py-2 bg-white text-black rounded-full font-medium\"\n        >\n          Retry\n        </button>\n      </div>\n    );\n  }\n\n  if (reels.length === 0) {\n    return (\n      <div className=\"h-screen w-full flex flex-col items-center justify-center bg-black text-white gap-4\">\n        <Hash className=\"w-16 h-16 text-gray-500\" />\n        <p className=\"text-xl\">No reels with #{hashtag}</p>\n        <button\n          onClick={() => router.push('/reels')}\n          className=\"px-6 py-2 bg-white text-black rounded-full font-medium\"\n        >\n          Go to Reels\n        </button>\n      </div>\n    );\n  }\n\n  return (\n    <div className=\"relative h-screen w-full bg-black\">\n      <div className=\"absolute top-0 left-0 right-0 z-20 pt-4 px-4 pb-2 bg-gradient-to-b from-black/80 to-transparent\">\n        <div className=\"flex items-center gap-4\">\n          <button\n            onClick={() => router.back()}\n            className=\"w-10 h-10 rounded-full bg-white/10 flex items-center justify-center hover:bg-white/20 transition-colors\"\n          >\n            <ArrowLeft className=\"w-5 h-5 text-white\" />\n          </button>\n          <div>\n            <h1 className=\"text-white text-xl font-bold flex items-center gap-1\">\n              <Hash className=\"w-5 h-5\" />\n              {hashtag}\n            </h1>\n            <p className=\"text-white/60 text-sm\">{reels.length} reels</p>\n          </div>\n        </div>\n      </div>\n\n      <div\n        className=\"h-screen w-full snap-y snap-mandatory overflow-y-scroll scrollbar-hide\"\n        onScroll={handleScroll}\n      >\n        {reels.map((reel, index) => (\n          <div\n            key={reel.id}\n            className=\"h-screen w-full snap-start snap-always\"\n          >\n            <ReelCard\n              reel={reel}\n              isActive={index === activeIndex}\n              isMuted={isMuted}\n              onMuteToggle={() => setIsMuted(!isMuted)}\n            />\n          </div>\n        ))}\n\n        {isFetchingNextPage && (\n          <div className=\"h-screen w-full flex items-center justify-center bg-black\">\n            <Loader2 className=\"w-12 h-12 text-white animate-spin\" />\n          </div>\n        )}\n      </div>\n    </div>\n  );\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}